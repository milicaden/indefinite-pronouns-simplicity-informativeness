library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(minpack.lm)
source("./Indefinites_functions.R")

####################################
# DATA
####################################
Folder = "../data/"

# Generate a data frame with all logically possible items (in terms of which functions they can take).
allpossibilities <- expand.grid(rep(list(0:1), 10))
colnames(allpossibilities) <- c("spec.know", "spec.unkn", "irr.nonsp", "question", "condit", "indir.neg", "dir.neg", "compar", "free.ch", "neg.frag")

# Remove the one item that cannot take any of the functions.
allpossibilities = subset(allpossibilities, !(spec.know== 0 & spec.unkn ==0 & irr.nonsp ==0 & question == 0 & condit ==  0 & indir.neg ==  0 & dir.neg ==  0 & compar ==  0 & free.ch ==  0 & neg.frag == 0))

# Determine which possibilities satisfy Haspelmath's universals
allpossibilities$Haspelmath <- ifelse(((allpossibilities$spec.know == 0|allpossibilities$irr.nonsp==0)|allpossibilities$spec.unkn==1) & ((allpossibilities$spec.unkn == 0|allpossibilities$question==0)|allpossibilities$irr.nonsp==1) & ((allpossibilities$spec.unkn == 0|allpossibilities$condit==0)|allpossibilities$irr.nonsp==1) & ((allpossibilities$irr.nonsp == 0|allpossibilities$indir.neg==0)|(allpossibilities$question==1|(allpossibilities$condit==1&allpossibilities$compar==1))) & ((allpossibilities$irr.nonsp == 0|allpossibilities$compar==0)|(allpossibilities$condit==1|(allpossibilities$question==1&allpossibilities$indir.neg==1))) & ((allpossibilities$question == 0|allpossibilities$compar==0)|(allpossibilities$condit==1|allpossibilities$indir.neg==1)) & ((allpossibilities$condit == 0|allpossibilities$indir.neg==0)|(allpossibilities$question==1|allpossibilities$compar==1)) & ((allpossibilities$question == 0|allpossibilities$dir.neg==0)|allpossibilities$indir.neg==1) & ((allpossibilities$dir.neg == 0|allpossibilities$compar==0)|allpossibilities$indir.neg==1) & ((allpossibilities$condit == 0|allpossibilities$free.ch==0)|allpossibilities$compar==1) & ((allpossibilities$indir.neg == 0|allpossibilities$free.ch==0)|allpossibilities$compar==1) & (allpossibilities$spec.know==0|allpossibilities$compar==0) & (allpossibilities$spec.know==0|allpossibilities$free.ch==0) & ((allpossibilities$question+allpossibilities$condit+allpossibilities$indir.neg+allpossibilities$compar ==0)|(allpossibilities$question+allpossibilities$condit+allpossibilities$indir.neg+allpossibilities$compar > 2)) & (allpossibilities$neg.frag == 0|allpossibilities$dir.neg==1), "Haspel-ok", "Haspel-notok")
haspelpossibilities <- subset(allpossibilities, Haspelmath == "Haspel-ok")


# Whether to generate languages + measure complexity, or read the info from files
generate <- FALSE

#############################
# Generate artificial languages whose words satisfy Haspelmath's implicational map
#############################
fakefilename <- paste0(Folder, 'artificial_languages_exp2.csv')

if(generate) {
  fakelangdfhaspok = generate_languages(1, 5000, haspelpossibilities)
  fakelangdfhaspok$type = "Haspel-ok"


#############################
# Generate artificial languages whose words do not necessarily satisfy Haspelmath's implicational map
#############################
  fakelangdfhaspnotok = generate_languages(5001, 10000, allpossibilities)
  fakelangdfhaspnotok$type = "Not Haspel-ok"

# Put Haspel ok and not Haspel ok languages in a single df
df <-rbind(fakelangdfhaspok, fakelangdfhaspnotok)

write.csv(df, fakefilename)
} else {
  df <- read.csv(fakefilename)
}

# Extract flavors for different items from Haspelmath's data based on our working assumptions
df = extract_flavors(df)

# Subset the data to relevant columns
relevant <- c("LANG", "ITEM", "skflavor", "suflavor", "nsflavor", "npiflavor", "fciflavor", "nqflavor", "Haspelmath", "type")
df <- df[relevant]

# Store the data
exp2languagesname = paste0(Folder, "languages_exp2.csv")
write.csv(df, exp2languagesname, row.names=FALSE)



